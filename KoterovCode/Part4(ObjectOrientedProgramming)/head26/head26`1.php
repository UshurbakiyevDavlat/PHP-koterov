<?php
    //Error catching and exceptions
        
        /**
            Error can be divided on 3 types:

                1) Error situation - error in a program , syntax(lost semicolon) or semantic(undefined variable using)
                2) Inner error - error that PHP sent to the user like open unexisting file
                3) User error - error that catched because incorrect data sent from user

        */

        /*
            Types of errors in detail:

                if in the program we have error situation and we need make a decision what we gotta do in this case,this code 
                is regenerative code after error and start of this code is regeneration after the error

                    $f = @fopen ("spoon.txt","r");
                    if (!$f) return 0;

                    in this case our if construction is regeneration code 
                    @ - it is operator to get PHP know that we do not want get its error message
                    
                Two big classes of errors:
                    Serious errors without automatic regeneration opportunity.For example you try to open inexist file 
                    and then get PHP know what to do if it can not be completed

                    Unserious errors - that type which does not require regeneration after it like: notice,warnings etc.

        
        */



        /*
            Control of errors

            One of the strong side of PHP that error message can be translated into browser directly
                Withou 500-th error of the server  

        */

        /*
            Directives of error control

                error_reporting
                Approximate values: numeric const (E_ALL - E_NOTICE as default)
                Loading into :php.ini , .htaccess, ini_set()

                Consts :
                        E_ERROR - fatal errors within time of executing the programm , stop the program
                        E_WARNING - warning within executing PHP progra, does not stop the program
                        E_PARSE - translation error , should generated only by parser of an original code
                        E_NOTICE - notice that pointed on something that can be a reason for the error
                        E_CORE_ERROR - fatal error of a core of PHP
                        E_CORE_WARNING - warning that generated by core of PHP
                        E_COMPILE_ERROR - fatal errors that generated within the compilation, generated by Zend
                        E_COMPILE_WARNING - warnings within the compilation, generated by Zend
                        E_USER_ERROR - fatal error that generated by PHP script with the help of trigger_error()
                        E_USER_WARNING - warning that generated by PHP script with the help of trigger_error()
                        E_USER_NOTICE - notice that generated by user with the help of trigger_error()
                        E_STRICT - different advices from PHP for old functions in the code for example
                        E_RECOVERABLE_ERROR - fatal errors with cover opportunity, generated only in that way that core of PHP in the normal condition.
                        E_DEPRECATED - notice that code include old-fashion functions
                        E_USER_DEPRECATED - notice that generated by PHP-script with the help of trigger_error()
                        E_ALL - all that above , excep E_STRICT (recomended put it as default in ini files)


                display_errors
                log_errors
                Approximate values: on ,off
                Loading into : php.ini, .htaccess,ini_set().

                If directive display_errors have into on value , all error messages go to the browser of user which started the script
                if also log_errors loaded so it means that messages go to the log file

                if you recovering script recommended display_errors on , if on the hosting recomended log_errors on


                error_log
                Approximate values: absolute path to the file(not covering by default)
                Loading into : php.ini , .htaccess, ini_set()

                    error_log put path to the log file

        
        */

        /*
            Setting showing errors mode

                    You also can modificate error_reporting() function
                        Recommended set up E_ALL mode in there
                        error_reporting(E_ALL);


            Errors Turn-off operator
                    @ - set it before any statement and all the errors will be ignored
                        if in the statement use result of function work and if from this result calling another function
                        then warning will be blocked for each of them!
                        
                    For example:
                        if (!@filemtime("notexstst.txt"))
                            echo "File is unexisted";


                    Values of the directives can be setted in the execution time, with help of ini_set()

                    @ operator can also block notices not only for browser but also for log-files

                    <?php
                        error_reporting(E_ALL);
                        ini_set("error_log","log.txt");
                        ini_set("log_errors",true);
                        @filemtime("spoon");

                    ?>

                    ini_set() - set config parameter $varname on $newvalue 
                    in example above we can see that log.txt did not even created
                        but if we remove @ operator in cause an error and this also will be writen in log.txt
                        

                Example of using @ operator :
                    
                    <?php
                        if (!empty($submit)) echo "Button has pressed";
                        ... 
                    ?>

                    or 
                    head26submit.php
                        
            Warning advices: 

                Where you better do not use:

                            -Do not use @ before included files!
                            -Do not use @ before PHP functions!

                Where you can use :
                        in the if (@$_REQUEST['key']) constructions for checking existence of array elements 
                        
                        before standard functions of PHP like : fopen(),filemtime(), mysql_connect() 
                            if then goes checking of the code and output error message.

                        in the HTML-files with PHP code segments to avoid apostrophs
                        <?= @$result[element][field]?>
                        
                        
            Catching errors:

                PHP has weapons to catch moment of error and happening some sort of error(or notice) and calling user-function:
                    set_error_handler()

                Register user error handler - function that will be called within error happened moment
                    pointed in $errorTypes(example:E_ALL ~ E_NOTICE)
                        (messages that not fitted to $errorsTypes will be handled by the inner PHP tools!)
                
                    Name of the user function will be setted to the $funcName parameter
                        and function return its name if you will need it to recover
                        
                            example in head26handler0.php

                        Unfortunately not all kind of errors can be catched this way 
                            E_PARSE AND E_ERROR will close program immediately , also die() and exit() can not be catched

                        In the case that our user error handler return false and only it
                            control under error catching getting to the PHP handler
                            All other values get to suppression start of standard procedure of error handle


                        Restoring previous error handler you can with:
                                restore_error_handler() like:
                                
                                set_error_handler("myErrorHandler",E_ALL);
                                include "suspicious.php";
                                restore_error_handler();

                        Number of calls restoring function should be equal to set_error_handler() calls



                Problems with @ operator 
                            Unfortunately user function of handling errors calling anyway.
                                Even if operator of suppresion errors is used in the moment of warning generation.
                            
                            To solve this problem we can use @ operator property
                                so, on time if its execution it set error_reporting equal to zero.

                            example in head26handler.php



                Error generation:

                                trigger_error() $error_msg,$error_type(E_USER_NOTICE by default)
                                    Allow generate errors of user level ,if one of this levels set return false other ways true 

                                example head26trigger_error.php 
                
                            error_log() $msg, $type ,$dest,$extra_headers
                                Write error message to  some file

                                $type == 0 (write messages to the system file of log, of file setted in the error_log)
                                $type == 1  (Send message on the mail ,in the $dest argument , and $extra_headers uses as additional headers)
                                $type == 3  messages added to the end of the file with name of $dest 

                Stack of the function calling 
                    debug_backtrace()
                    
                    example head26trace.php


                Exceptions 
                    Mechanism of handling exceptions or as default in OOP just "exception" - it is techonlogy allows write 
                    code of regeneration after fatal error in comfortable form

                **Data should be handle in that segment of the programm that has maximum knowledges about how to do it.

                simple example in head26simple.php

                throw instruction 
                    not just generate object-exception and give it to the handler catch block.
                    It is also imediately end the current try block 


                Stack unwinding:
                    example in head26stack.php

                
                Exceptions and destructors:
                    example in head26destr.php (also stack unwinding)


                Exceptions and set_error_handler() disadvantage of the last
                    example in head26seh.php


                Classification and Inheritance
                    head26inherit.php


                Base class Exception
                    we have in Exception class theese properties and methods:
                        protected $message;
                        protected $code;
                        protected $file;
                        protected $line;
                        private $trace;
                        public function __construct([string message][,int $code]);
                        public final function getMessage();
                        public final function getCode();
                        public final function getFile();
                        public final function getLine();
                        public final function getTrace();
                        public final function getTraceAsString();
                        public function __toString();

                    example in head26toString.php

                Classification exceptions with interfaces example in 
                    head26iface/interfaces.php
                internal errors : detailed information in the browser is not showing ,but writen into log file
                    also diveded to the:
                        file errors: open,read or write error
                        net errors: imposible connect to the server

                user errors: message goes to the browser directly.

                so interfaces do not include any method or propertie and need only for creating structure of classification.

                Now, if in the program we have object-exception which class implement interface INetException, we also can see
                    that it is implementing IInternalException interface as well
                    if ($obj instanceof IInternalException) echo "It is internal error!";
                    and we can catch  any exception that implementing IFileException and INetException

                    so in the head26iface/exceptions.php we creating classes that implementing our interfaces
                    and in head26iface/test.php we can use all the hierarchy of the exceptions


            Exceptions in PHP7 
                In PHP7 changed conception of error messages: most of them forming in the exceptions of special type Error.
                This class is not inherited from Exception 
                    example in head26error.php

                    Hierarchy classes that inherited from Error:
                        ArithmeticError - in ariphmetic operations
                        AssertionError - in case of assert() function
                        DivisionByZeroError - in division by zero case
                        ParseError - in case that PHP code can not be parsed, for example in eval()
                        TypeError - type case error

                        <?php
                            try{
                                $str = "Hello World!";
                                $str[] = 4;
                            }catch(TypeError $e){
                                echo "Type error detected!";
                            }
                        ?>

                    
                Finaly blocks
                      construction that allows to us do some final action before it end the program because of throw exception 
                      example in head26finally.php
                      
                    Also we can catch all the Exceptions:
                            example in head26catchall.php

                Error Transformation:
                    seriousness of unserious errors:
                        So, fatality of errors can be also fatal and not
                        
                        for example for warnings:
                            *Can not open the file fatal, so all of the work of the script do not have any sense then.
                            *Can not open the file None-Fatal, so it can be just checking of the existence of the file.
                            
                        for example for notices:
                            *in SQL-require it is very fatal if something will go in the incorect case because of wrong data in the propertie, but at the same time correct syntax
                            *and none fatal if it just noticing about initializing
                        

                Error convertation to the Exception:
                            So, we saw that error of any level we can tractate as serious.
                                if we do not put @ - operator before statement.
                            And for serious errors we use Exceptions

                    For example:
                           library for  automaticly transformation of all catched errors 
                           in head26w2e_simple.php
                            

        */


?>